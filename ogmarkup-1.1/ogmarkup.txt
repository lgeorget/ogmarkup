-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language Markup Parser for Ogma
--   
--   Please see README.md
@package ogmarkup
@version 1.1

module Text.Ogmarkup.Private.Ast

-- | A ogmarkup document internal representation waiting to be used in
--   order to generate an output.
type Document a = [Section a]
data Section a

-- | The story as it goes
Story :: [Paragraph a] -> Section a

-- | Something else. Maybe a letter, a flashback, etc.
Aside :: (Maybe a) -> [Paragraph a] -> Section a
type Paragraph a = [Component a]
data Component a

-- | A narrative description
Teller :: [Format a] -> Component a

-- | A dialogue reply
Dialogue :: (Reply a) -> (Maybe a) -> Component a

-- | Inner dialogue of the character.
Thought :: (Reply a) -> (Maybe a) -> Component a

-- | A character line of dialogue. A reply may contain a descriptive part,
--   which is not part of what the character actually says or thinks. We
--   call the latter a "with say" reply untill someone gives use a better
--   name for it.
data Reply a

-- | A reply of the form: "Good morning."
Simple :: [Format a] -> Reply a

-- | A reply of the form: "Good morning," she says. "How are you?"
WithSay :: [Format a] -> [Format a] -> [Format a] -> Reply a

-- | A nested formatted text
data Format a

-- | No particular emphasis is required on this sequence
Raw :: [Atom a] -> Format a

-- | Surrounded by <tt>*</tt>.
Emph :: [Format a] -> Format a

-- | Surrounded by <tt>**</tt>.
StrongEmph :: [Format a] -> Format a
Quote :: [Format a] -> Format a

-- | An Atom is the atomic component of a Ogmarkup document. It can be
--   either a punctuation mark or a word, that is a string.
--   
--   Note that, by construction, <a>OpenQuote</a> and <a>CloseQuote</a> are
--   not valid <a>Mark</a> values here. Indeed, they are implicit with the
--   <a>Quote</a> constructor. This choice allows to enforce that an opened
--   quote needs to be closed.
data Atom a

-- | A wrapped string
Word :: a -> Atom a

-- | A punctuation mark
Punctuation :: Mark -> Atom a

-- | Mostly in order to deal with typographic spaces, main punctuation
--   marks are tokenized during the parsing of an Ogmarkup document.
data Mark

-- | The character <tt>;</tt>
Semicolon :: Mark

-- | The character <tt>,</tt>
Colon :: Mark

-- | The character <tt>?</tt>
Question :: Mark

-- | The character <tt>!</tt>
Exclamation :: Mark

-- | The character <tt>"</tt>
OpenQuote :: Mark

-- | The character <tt>"</tt>
CloseQuote :: Mark

-- | The character – or the sequence <tt>--</tt>
Dash :: Mark

-- | The character — or the sequence <tt>---</tt>
LongDash :: Mark

-- | The character <tt>,</tt>
Comma :: Mark

-- | The character <tt>.</tt>
Point :: Mark

-- | The character <tt>-</tt>
Hyphen :: Mark

-- | Two or more <tt>.</tt> or the character …
SuspensionPoints :: Mark

-- | The characters <tt>'</tt> or <tt>’</tt>
Apostrophe :: Mark
instance GHC.Show.Show a => GHC.Show.Show (Text.Ogmarkup.Private.Ast.Section a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Ogmarkup.Private.Ast.Section a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Ogmarkup.Private.Ast.Component a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Ogmarkup.Private.Ast.Component a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Ogmarkup.Private.Ast.Reply a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Ogmarkup.Private.Ast.Reply a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Ogmarkup.Private.Ast.Format a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Ogmarkup.Private.Ast.Format a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Text.Ogmarkup.Private.Ast.Atom a)
instance GHC.Show.Show a => GHC.Show.Show (Text.Ogmarkup.Private.Ast.Atom a)
instance GHC.Classes.Eq Text.Ogmarkup.Private.Ast.Mark
instance GHC.Show.Show Text.Ogmarkup.Private.Ast.Mark


-- | This module provides several parsers that can be used in order to
--   extract the <tt>Ast</tt> of an Ogmarkup document.
--   
--   Please consider that only <a>document</a> should be used outside this
--   module.
module Text.Ogmarkup.Private.Parser

-- | Keep track of the currently opened formats.
data ParserState
ParserState :: Bool -> Bool -> Bool -> ParserState

-- | Already parsing text with emphasis
[parseWithEmph] :: ParserState -> Bool

-- | _Already parsing text with strong emphasis
[parseWithStrongEmph] :: ParserState -> Bool

-- | _Already parsing a quote
[parseWithinQuote] :: ParserState -> Bool
enterEmph :: OgmarkupParser ()
leaveEmph :: OgmarkupParser ()
enterStrongEmph :: OgmarkupParser ()
leaveStrongEmph :: OgmarkupParser ()
enterQuote :: OgmarkupParser ()
leaveQuote :: OgmarkupParser ()
initParserState :: ParserState

-- | An ogmarkup parser processes <a>Char</a> tokens and carries a
--   <a>ParserState</a>
type OgmarkupParser = GenParser Char ParserState
parse :: OgmarkupParser a -> String -> String -> Either ParseError a
withEmph :: OgmarkupParser Bool
withStrongEmph :: OgmarkupParser Bool
withinQuote :: OgmarkupParser Bool

-- | See <a>Document</a>.
document :: IsString a => OgmarkupParser (Document a)

-- | See <a>Section</a>.
section :: IsString a => OgmarkupParser (Section a)

-- | See <a>Aside</a>.
aside :: IsString a => OgmarkupParser (Section a)

-- | See <a>Story</a>.
story :: IsString a => OgmarkupParser (Section a)

-- | See <a>Paragraph</a>.
paragraph :: IsString a => OgmarkupParser (Paragraph a)

-- | See <a>Component</a>.
component :: IsString a => OgmarkupParser (Component a)

-- | See <a>Teller</a>.
teller :: IsString a => OgmarkupParser (Component a)

-- | See <a>Dialogue</a>.
dialogue :: IsString a => OgmarkupParser (Component a)

-- | See <a>Thought</a>.
thought :: IsString a => OgmarkupParser (Component a)

-- | <tt><a>talk</a> c c' constr</tt> wrap a reply surrounded by <tt>c</tt>
--   and <tt>c'</tt> inside <tt>constr</tt> (either <a>Dialogue</a> or
--   <a>Thought</a>).
talk :: IsString a => Char -> Char -> (Reply a -> Maybe a -> Component a) -> OgmarkupParser (Component a)
authorName :: IsString a => OgmarkupParser a

-- | <a>reply</a> parses a <a>Reply</a>.
reply :: IsString a => Char -> Char -> OgmarkupParser (Reply a)

-- | See <a>Format</a>.
format :: IsString a => OgmarkupParser (Format a)

-- | See <a>Raw</a>.
raw :: IsString a => OgmarkupParser (Format a)

-- | See <a>Emph</a>.
emph :: IsString a => OgmarkupParser (Format a)

-- | See <a>StrongEmph</a>.
strongEmph :: IsString a => OgmarkupParser (Format a)
quote :: IsString a => OgmarkupParser (Format a)

-- | See <a>Atom</a>.
atom :: IsString a => OgmarkupParser (Atom a)

-- | See <a>Word</a>. This parser does not consume the following spaces, so
--   the caller needs to take care of it.
word :: IsString a => OgmarkupParser (Atom a)

-- | Wrap a raw string surrounded by <tt>`</tt> inside a <a>Word</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parse longword "" "`test *ei*`"
--   Right (Ast.Word "test *ei*")
--   </pre>
--   
--   Therefore, <tt>`</tt> can be used to insert normally reserved symbol
--   inside a generated document.
longword :: IsString a => OgmarkupParser (Atom a)

-- | See <a>Punctuation</a>. Be aware that <a>mark</a> does not parse the
--   quotes because they are processed <a>quote</a>.
mark :: OgmarkupParser (Atom a)

-- | See <a>OpenQuote</a>. This parser consumes the following blank (see
--   <a>blank</a>) and skip the result.
openQuote :: OgmarkupParser ()

-- | See <a>CloseQuote</a>. This parser consumes the following blank (see
--   <a>blank</a>) and skip the result.
closeQuote :: OgmarkupParser ()

-- | An aside section (see <a>Aside</a>) is a particular region surrounded
--   by two lines of underscores (at least three). This parser consumes one
--   such line.
asideSeparator :: OgmarkupParser ()

-- | This parser consumes all the white spaces until it finds either an
--   aside surrounding marker (see <a>Aside</a>), the end of the document
--   or one blank line. The latter marks the end of the current paragraph.
blank :: OgmarkupParser ()

-- | <tt>skip p</tt> parses <tt>p</tt> and skip the result
skip :: OgmarkupParser a -> OgmarkupParser ()

module Text.Ogmarkup.Private.Typography

-- | Deal with typographic spaces, especially when it comes to separate two
--   texts. Because Space derives Ord, it is possible to use min and max to
--   determine which one to use in case of a conflict.
data Space

-- | A normal space that can be turned into a newline for displaying.
Normal :: Space

-- | A non breakable space, it cannot be turned into a newline.
Nbsp :: Space

-- | No space at all.
None :: Space

-- | A Typography is a data type that tells the caller what space she
--   should privileged before and after a text.
data Typography a
Typography :: (Mark -> (Space, Space, a)) -> (Bool -> Maybe Mark) -> (Bool -> Maybe Mark) -> Typography a
[decide] :: Typography a -> Mark -> (Space, Space, a)
[openDialogue] :: Typography a -> Bool -> Maybe Mark
[closeDialogue] :: Typography a -> Bool -> Maybe Mark

-- | From a Typography, it gives the space to privilege before the input
--   Text.
beforeAtom :: Typography a -> Atom a -> Space

-- | From a Typography, it gives the space to privilege after the input
--   Text.
afterAtom :: Typography a -> Atom a -> Space

-- | Normalize the input in order to add it to a generated Text.
normalizeAtom :: Typography a -> Atom a -> a

-- | A proposal for tho French typography. It can be used with several
--   generation approach, as it stay very generic. Required the output type
--   to be an instance of <a>IsString</a>.
frenchTypo :: IsString a => Typography a

-- | A proposal for tho English typography. It can be used with several
--   generation approach, as it stay very generic. Required the output type
--   to be an instance of <a>IsString</a>.
englishTypo :: IsString a => Typography a
instance GHC.Classes.Ord Text.Ogmarkup.Private.Typography.Space
instance GHC.Classes.Eq Text.Ogmarkup.Private.Typography.Space
instance GHC.Base.Functor Text.Ogmarkup.Private.Typography.Typography

module Text.Ogmarkup.Private.Config
type Template a = a -> a

-- | A data type to carry out the generation configuration. In particular,
--   it works well to define a Typography and some marker such as HTML
--   tags.
data GenConf a
GenConf :: Typography a -> Template a -> Template a -> (Maybe a -> Template a) -> Template a -> Template a -> (a -> Template a) -> (a -> Template a) -> Template a -> a -> Template a -> Template a -> (Maybe a -> a) -> (Space -> a) -> GenConf a

-- | The Typography to use for the generation
[typography] :: GenConf a -> Typography a
[documentTemplate] :: GenConf a -> Template a
[storyTemplate] :: GenConf a -> Template a
[asideTemplate] :: GenConf a -> Maybe a -> Template a
[paragraphTemplate] :: GenConf a -> Template a
[tellerTemplate] :: GenConf a -> Template a
[dialogueTemplate] :: GenConf a -> a -> Template a
[thoughtTemplate] :: GenConf a -> a -> Template a
[replyTemplate] :: GenConf a -> Template a
[betweenDialogue] :: GenConf a -> a
[emphTemplate] :: GenConf a -> Template a
[strongEmphTemplate] :: GenConf a -> Template a
[authorNormalize] :: GenConf a -> Maybe a -> a
[printSpace] :: GenConf a -> Space -> a

module Text.Ogmarkup.Private.Generator

-- | The <a>Generator</a> Monad is eventually used to generate an output
--   from a given 'Ast.Document. Internally, it keeps track of the previous
--   processed <a>Atom</a> in order to deal with atom separation.
newtype Generator a x
Generator :: StateT (a, Maybe (Atom a)) (Reader (GenConf a)) x -> Generator a x
[getState] :: Generator a x -> StateT (a, Maybe (Atom a)) (Reader (GenConf a)) x

-- | Run a <a>Generator</a> monad and get the generated output. The output
--   type has to implement the class <a>Monoid</a> because the
--   <a>Generator</a> monad uses the <a>mempty</a> constant as the initial
--   state of the output and then uses <a>mappend</a> to expand the result
--   as it process the generation.
runGenerator :: Monoid a => Generator a x -> GenConf a -> a

-- | Retreive a configuration parameter. Let the output untouched.
askConf :: (GenConf a -> b) -> Generator a b

-- | Apply a template to the result of a given <a>Generator</a> before
--   appending it to the previously generated output.
apply :: Monoid a => Template a -> Generator a x -> Generator a ()

-- | Forget about the past and consider the next <a>Atom</a> is the first
--   to be processed.
reset :: Generator a ()

-- | Append a new sub-output to the generated output
raw :: Monoid a => a -> Generator a ()

-- | Process an <a>Atom</a> and deal with the space to use to separate it
--   from the paramter of the previous call (that is the previous processed
--   <a>Atom</a>).
atom :: Monoid a => Atom a -> Generator a ()

-- | Call <a>atom</a> if the parameter is not <a>Nothing</a>. Otherwise, do
--   nothing.
maybeAtom :: Monoid a => Maybe (Atom a) -> Generator a ()

-- | Process a sequence of <a>Atom</a>.
atoms :: Monoid a => [Atom a] -> Generator a ()

-- | Process a <a>Format</a>.
format :: Monoid a => Format a -> Generator a ()

-- | Process a sequence of <a>Format</a>.
formats :: Monoid a => [Format a] -> Generator a ()

-- | Process a <a>Reply</a>.
reply :: Monoid a => Maybe (Atom a) -> Maybe (Atom a) -> Reply a -> Generator a ()

-- | Process a <a>Component</a>.
component :: Monoid a => Bool -> Bool -> Component a -> Generator a ()

-- | Process a <a>Paragraph</a> and deal with sequence of <a>Reply</a>.
paragraph :: Monoid a => Paragraph a -> Generator a ()

-- | Process a sequence of <a>Paragraph</a>.
paragraphs :: Monoid a => [Paragraph a] -> Generator a ()

-- | Process a <a>Section</a>.
section :: Monoid a => Section a -> Generator a ()

-- | Process a sequence of <a>Section</a>.
sections :: Monoid a => [Section a] -> Generator a ()

-- | Process a <a>Document</a>, that is a complete Ogmarkup document
document :: Monoid a => Document a -> Generator a ()
instance Control.Monad.Reader.Class.MonadReader (Text.Ogmarkup.Private.Config.GenConf a) (Text.Ogmarkup.Private.Generator.Generator a)
instance Control.Monad.State.Class.MonadState (a, GHC.Base.Maybe (Text.Ogmarkup.Private.Ast.Atom a)) (Text.Ogmarkup.Private.Generator.Generator a)
instance GHC.Base.Monad (Text.Ogmarkup.Private.Generator.Generator a)
instance GHC.Base.Applicative (Text.Ogmarkup.Private.Generator.Generator a)
instance GHC.Base.Functor (Text.Ogmarkup.Private.Generator.Generator a)

module Text.Ogmarkup

-- | From a String, parse and generate an output according to a generation
--   configuration. The inner definitions of the parser and the generator
--   implies the output type has to be an instance of the <a>IsString</a>
--   and <a>Monoid</a> classes.
ogmarkup :: (IsString a, Monoid a) => String -> GenConf a -> Either ParseError a

-- | A data type to carry out the generation configuration. In particular,
--   it works well to define a Typography and some marker such as HTML
--   tags.
data GenConf a
GenConf :: Typography a -> Template a -> Template a -> (Maybe a -> Template a) -> Template a -> Template a -> (a -> Template a) -> (a -> Template a) -> Template a -> a -> Template a -> Template a -> (Maybe a -> a) -> (Space -> a) -> GenConf a

-- | The Typography to use for the generation
[typography] :: GenConf a -> Typography a
[documentTemplate] :: GenConf a -> Template a
[storyTemplate] :: GenConf a -> Template a
[asideTemplate] :: GenConf a -> Maybe a -> Template a
[paragraphTemplate] :: GenConf a -> Template a
[tellerTemplate] :: GenConf a -> Template a
[dialogueTemplate] :: GenConf a -> a -> Template a
[thoughtTemplate] :: GenConf a -> a -> Template a
[replyTemplate] :: GenConf a -> Template a
[betweenDialogue] :: GenConf a -> a
[emphTemplate] :: GenConf a -> Template a
[strongEmphTemplate] :: GenConf a -> Template a
[authorNormalize] :: GenConf a -> Maybe a -> a
[printSpace] :: GenConf a -> Space -> a
type Template a = a -> a

-- | A proposal for tho French typography. It can be used with several
--   generation approach, as it stay very generic. Required the output type
--   to be an instance of <a>IsString</a>.
frenchTypo :: IsString a => Typography a

-- | A proposal for tho English typography. It can be used with several
--   generation approach, as it stay very generic. Required the output type
--   to be an instance of <a>IsString</a>.
englishTypo :: IsString a => Typography a

-- | A Typography is a data type that tells the caller what space she
--   should privileged before and after a text.
data Typography a
Typography :: (Mark -> (Space, Space, a)) -> (Bool -> Maybe Mark) -> (Bool -> Maybe Mark) -> Typography a
[decide] :: Typography a -> Mark -> (Space, Space, a)
[openDialogue] :: Typography a -> Bool -> Maybe Mark
[closeDialogue] :: Typography a -> Bool -> Maybe Mark

-- | Mostly in order to deal with typographic spaces, main punctuation
--   marks are tokenized during the parsing of an Ogmarkup document.
data Mark

-- | The character <tt>;</tt>
Semicolon :: Mark

-- | The character <tt>,</tt>
Colon :: Mark

-- | The character <tt>?</tt>
Question :: Mark

-- | The character <tt>!</tt>
Exclamation :: Mark

-- | The character <tt>"</tt>
OpenQuote :: Mark

-- | The character <tt>"</tt>
CloseQuote :: Mark

-- | The character – or the sequence <tt>--</tt>
Dash :: Mark

-- | The character — or the sequence <tt>---</tt>
LongDash :: Mark

-- | The character <tt>,</tt>
Comma :: Mark

-- | The character <tt>.</tt>
Point :: Mark

-- | The character <tt>-</tt>
Hyphen :: Mark

-- | Two or more <tt>.</tt> or the character …
SuspensionPoints :: Mark

-- | The characters <tt>'</tt> or <tt>’</tt>
Apostrophe :: Mark

-- | Deal with typographic spaces, especially when it comes to separate two
--   texts. Because Space derives Ord, it is possible to use min and max to
--   determine which one to use in case of a conflict.
data Space

-- | A normal space that can be turned into a newline for displaying.
Normal :: Space

-- | A non breakable space, it cannot be turned into a newline.
Nbsp :: Space

-- | No space at all.
None :: Space
